package com.zhb.chap9Apache_DBUtilsCRUD;

/**
 * @author zhb
 * @create 2022-02-19 21:13
 */

/**
 * ## 第9章：Apache-DBUtils实现CRUD操作
 *
 * ### 9.1 Apache-DBUtils简介
 * 9.2 主要API的使用
 *      9.2.1 DbUtils
 *      9.2.2 QueryRunner类
 *      9.2.3 ResultSetHandler接口及实现类
 *
 */

/*
### 9.1 Apache-DBUtils简介

crud是指在做计算处理时的增加(Create)、检索(Retrieve)
、更新(Update)和删除(Delete)几个单词的首字母简写。
crud主要被用在描述软件系统中数据库或者持久层的基本操作功能。

- commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。

- API介绍：
  - org.apache.commons.dbutils.QueryRunner
  - org.apache.commons.dbutils.ResultSetHandler
  - 工具类：org.apache.commons.dbutils.DbUtils
- API包说明：

 */

/*
### 9.2 主要API的使用

#### 9.2.1 DbUtils

- DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
  - **public static void close(…) throws java.sql.SQLException**：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。
  - public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。
  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接
  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。
  - public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断
  - public static void rollbackAndClose(Connection conn)throws SQLException
  - rollbackAndCloseQuietly(Connection)
  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。

#### 9.2.2 QueryRunner类

- **该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。**

- QueryRunner类提供了两个构造器：
  - 默认的构造器
  - 需要一个 javax.sql.DataSource 来作参数的构造器

- QueryRunner类的主要方法：
  - **更新**
    - public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。
    - ......
  - **插入**
    - public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值
    - ....
  - **批处理**
    - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句
    - public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句
    - .....
  - **查询**
    - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。
    - ......

- 测试
 */
// 测试添加

//import org.junit.jupiter.api.Test;
//
//@Test
//public void testInsert() throws Exception {
//        QueryRunner runner = new QueryRunner();
//        Connection conn = JDBCUtils.getConnection3();
//        String sql = "insert into customers(name,email,birth)values(?,?,?)";
//        int count = runner.update(conn, sql, "何成飞", "he@qq.com", "1992-09-08");
//
//        System.out.println("添加了" + count + "条记录");
//
//        JDBCUtils.closeResource(conn, null);
//
//        }
//
//// 测试删除
//@Test
//public void testDelete() throws Exception {
//        QueryRunner runner = new QueryRunner();
//        Connection conn = JDBCUtils.getConnection3();
//        String sql = "delete from customers where id < ?";
//        int count = runner.update(conn, sql,3);
//
//        System.out.println("删除了" + count + "条记录");
//
//        JDBCUtils.closeResource(conn, null);
//
//        }
//

/*
#### 9.2.3 ResultSetHandler接口及实现类

- 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。

- ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。

- 接口的主要实现类：

  - ArrayHandler：把结果集中的第一行数据转成对象数组。

  - ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。

  - **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。

  - **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。

  - ColumnListHandler：将结果集中某一列的数据存放到List中。

  - KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。

  - **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。

  - **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List

  - **ScalarHandler：**查询单个值对象



- 测试
// */
///*
// * 测试查询:查询一条记录
// *
// * 使用ResultSetHandler的实现类：BeanHandler
// */
//
//import org.junit.jupiter.api.Test;
//
//@Test
//public void testQueryInstance() throws Exception{
//        QueryRunner runner = new QueryRunner();
//
//        Connection conn = JDBCUtils.getConnection3();
//
//        String sql = "select id,name,email,birth from customers where id = ?";
//
//        //
//        BeanHandler<Customer> handler = new BeanHandler<>(Customer.class);
//        Customer customer = runner.query(conn, sql, handler, 23);
//        System.out.println(customer);
//        JDBCUtils.closeResource(conn, null);
//        }
//
///*
// * 测试查询:查询多条记录构成的集合
// *
// * 使用ResultSetHandler的实现类：BeanListHandler
// */
//@Test
//public void testQueryList() throws Exception{
//        QueryRunner runner = new QueryRunner();
//
//        Connection conn = JDBCUtils.getConnection3();
//
//        String sql = "select id,name,email,birth from customers where id < ?";
//
//        //
//        BeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);
//        List<Customer> list = runner.query(conn, sql, handler, 23);
//        list.forEach(System.out::println);
//
//        JDBCUtils.closeResource(conn, null);
//        }
//
///*
// * 自定义ResultSetHandler的实现类
// */
//@Test
//public void testQueryInstance1() throws Exception{
//        QueryRunner runner = new QueryRunner();
//
//        Connection conn = JDBCUtils.getConnection3();
//
//        String sql = "select id,name,email,birth from customers where id = ?";
//
//        ResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {
//
//@Override
//public Customer handle(ResultSet rs) throws SQLException {
//        System.out.println("handle");
////			return new Customer(1,"Tom","tom@126.com",new Date(123323432L));
//
//        if(rs.next()){
//        int id = rs.getInt("id");
//        String name = rs.getString("name");
//        String email = rs.getString("email");
//        Date birth = rs.getDate("birth");
//
//        return new Customer(id, name, email, birth);
//        }
//        return null;
//
//        }
//        };
//
//        Customer customer = runner.query(conn, sql, handler, 23);
//
//        System.out.println(customer);
//
//        JDBCUtils.closeResource(conn, null);
//        }
//
///*
// * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，
// * 使用ScalarHandler
// *
// */
//@Test
//public void testQueryValue() throws Exception{
//        QueryRunner runner = new QueryRunner();
//
//        Connection conn = JDBCUtils.getConnection3();
//
//        //测试一：
////	String sql = "select count(*) from customers where id < ?";
////	ScalarHandler handler = new ScalarHandler();
////	long count = (long) runner.query(conn, sql, handler, 20);
////	System.out.println(count);
//
//        //测试二：
//        String sql = "select max(birth) from customers";
//        ScalarHandler handler = new ScalarHandler();
//        Date birth = (Date) runner.query(conn, sql, handler);
//        System.out.println(birth);
//
//        JDBCUtils.closeResource(conn, null);
//        }
//

public class Apache_DBUtilsTest {
    // 测试添加
   /* @Test
    public void testInsert() throws Exception {
        QueryRunner runner = new QueryRunner();

        Connection conn = JDBCUtils.getConnection3();
        String sql = "insert into customers(name,email,birth)values(?,?,?)";
        int count = runner.update(conn, sql, "何成飞", "he@qq.com", "1992-09-08");

        System.out.println("添加了" + count + "条记录");

        JDBCUtils.closeResource(conn, null);

    }
    // 测试删除
    @Test
    public void testDelete() throws Exception {
        QueryRunner runner = new QueryRunner();
        Connection conn = JDBCUtils.getConnection3();
        String sql = "delete from customers where id < ?";
        int count = runner.update(conn, sql,3);

        System.out.println("删除了" + count + "条记录");

        JDBCUtils.closeResource(conn, null);

    }*/
}
